{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome.","text":"<p>I'm Mike Mol, a software engineer, SRE and systems architect who enjoys untangling complex problems in distributed systems.</p> <p>With over 15 years of experience in Site Reliability Engineering (SRE), DevOps, and cloud infrastructure, I've had the opportunity to work on a wide range of challenging projects at companies like Google and Ford.</p> <p>This blog is a space for me to explore the technical topics that I find interesting, from automation and CI/CD pipelines to the intersection of infrastructure and AI/ML. Here, you'll find my thoughts on various technologies, projects I'm working on, and the occasional \"Mike Reads\" or \"Mike Writes\" entry, where I delve into my other interests.</p> <p>Feel free to look around and check out my blog posts.</p>"},{"location":"blog/","title":"Blog","text":"<p>A collection of posts...</p>"},{"location":"blog/#2022","title":"2022","text":"<ul> <li>Phoenix Guards Pt 1</li> <li>Mike Writes</li> <li>Mike Reads</li> </ul>"},{"location":"blog/#2020","title":"2020","text":"<ul> <li>On Github Actions Security Controls</li> </ul>"},{"location":"blog/#2018","title":"2018","text":"<ul> <li>Vdi And Containers</li> <li>Graphviz Dot Basics Pt 2</li> <li>Graphviz Dot Basics Pt 1</li> <li>Link Rollup</li> <li>Asset Regeneration Script</li> <li>Color Safe Palette</li> <li>Hardware Touchpad Troubles</li> <li>Graphviz Sh Zsh Bash Refactor</li> <li>Graphviz Technique Nodes As Edge Labels</li> <li>Blog Workflow</li> <li>Graphviz Jekyll Js</li> <li>Ifttt Integration Test F1Edfb94 570F 48C3 98A7 8Baf826205C4</li> <li>Here I Go Again With A Blog</li> <li>Blank Renders</li> </ul>"},{"location":"blog/2018/01/05/blank-renders/","title":"Blank Renders","text":"<p>Somewhat annoyed. If I try to use any theme but minima, I get just a couple of blank lines emitted to me by GitHub Pages. Research suggests that means a suppressed error message, but that...doesn't help me in the slightest. The usability isn't great, honestly.</p> <p>I'm sure if I knew what I was doing with Jekyll and GH Pages, I wouldn't have had this problem. But I would have liked it if using the theme selector didn't result in a site that wouldn't render.</p> <p>Whelp. Hopefully, I'll be able to write about the stuff I wanted to write about, tomorrow. Tonight, time for bed...</p>"},{"location":"blog/2018/01/05/here-i-go-again-with-a-blog/","title":"Here I Go Again with a Blog","text":"<p>Maybe this one will stick since GitHub seems to be a place that doesn't want to go away. (Waves to Slashdot Journals, LiveJournal, Multiply...)</p> <p>Besides, I like git.</p>"},{"location":"blog/2018/01/06/ifttt-integration-test-f1edfb94-570f-48c3-98a7-8baf826205c4/","title":"IFTTT Integration Test f1edfb94-570f-48c3-98a7-8baf826205c4","text":"<p>So, when this post goes live, it should get picked up by IFTTT and shared on my Twitter, Facebook, LinkedIn and Reddit (profile page) places.</p> <p>For your amusement, I've attached a UUID to the title of this post to make those things easier to search for. :)</p>"},{"location":"blog/2018/01/07/graphviz-jekyll-js/","title":"Graphviz content in Jekyll via Javascript","text":"<p>So, most of what I want to write about (if you dig around GitHub, you can find my backlog as a bunch of empty draft posts) involves Dot and GraphViz. But as nice as Jekyll and Markdown are for blog posts, the simplest workflow has me separately building Graphviz assets into PNG or SVG and embedding them, and then due to GitHub limitations, ditching the SVG version, generating the PNG version at a silly size and scaling it down:</p> <pre><code>digraph graphviz_workflow {\n    write_asset -&gt; {svg png} [label=\"Emit outputs\"]\n    svg -&gt; discard [label=\"GH Pages doesn't like SVG\"]\n    png -&gt; rebuild -&gt; embed -&gt; {rewrite_asset done}\n\n    rewrite_asset -&gt; rebuild\n\n    write_asset [label=\"Write DOT\\nSeparately\"]\n    rebuild [label=\"Rebuild asset\\nat higherDPI\\nand scale down\"]\n    rewrite_asset [label=\"Tweak asset\\nfor use case\"]\n}\n</code></pre> <p>...except here's the real problem: You're looking at a Dot representation of the workflow I just mentioned, not a visual representation. What I want is to be able to write Dot code in line with my posts, and have that content presented to you visually.</p> <p>It looks like what I want is a Jekyll generator module that will let me convert inline Dot code like the above into something visual. These exist, but the ones I've found so far call out to an installation of Graphviz that's on the server to do the render work.</p> <p>If I'm using somebody else's server (i.e. GitHub Pages, as I am at the moment), that's not a solution I care for; it means hoping their Jekyll setup permits call-outs like that, hoping it has Graphviz installed, hoping it's the right version...if I was running a server, especially a free service, I would discourage users from executing arbitrary code.</p> <p>Instead, I think what I'd like is a generator module that embeds vis-js, a Javascript GraphViz implementation and has the render work performed on the client side. Falling back to a cruddy pre-rendered PNG if that's not possible.</p> <p>I think that workflow would work a lot better for me. So instead of the Dot code, you see above, you'd see a clean, SVG-defined inline-image. And if that didn't get rendered, you'd at least see a static pre-rendered PNG that looks something like this:</p> <p></p> <p>So, you might not see quite what's wrong with that. Admittedly, it does look better than if I were to render that content on my work laptop. Here, the font-kerning is horrible, but at least the font hinting works better. I've got a separate post (or a few) on that topic.</p> <p>Though, text rendering belongs on the client. The client knows about the display, knows about pixel size, shape, subpixel orientation, etc.</p> <p>So, real quick, let's find out if client-side rendering is the proper solution to this.</p> <p></p> <p>Now, that renders fine using Jekyll and local preview on my laptop. But will it be when I upload this doc to GitHub? I've heard it doesn't, but we'll have to see!</p>"},{"location":"blog/2018/01/09/blog-workflow/","title":"Blog Workflow","text":"<p>So, I was asked what my \"platform\" was, and I wasn't exactly sure what was meant. I can, however, discuss the tools and workflow involved, and take advantage of that discussion to refine it a bit. I might even create a dedicated page to it at some point.</p> <p>So, here's a chart of the content flow and the tools content passes through.</p> <p></p>"},{"location":"blog/2018/01/09/blog-workflow/#content-is-authored-in-visual-studio-code","title":"Content is authored in Visual Studio Code","text":"<p>With its ability to preview Markdown and Dot, Visual Studio Code makes for a great WYSIWYM editor.</p> <p>Its strong Git integration makes storing the blog source in Git a natural conclusion. (And if you want to cheat and peek under the hood for this blog, you can do that. Feel free to judge me for the consistency of my git behavior. Keeps me honest.)</p>"},{"location":"blog/2018/01/09/blog-workflow/#graphic-artifacts-are-rendered-using-graphviz","title":"Graphic artifacts are rendered using GraphViz","text":"<p>I'm not hot with Inkscape. I don't have Adobe whatever. But, frankly, images are for telling stories, and the Dot language is fantastic for helping you define your image as a story. For example, you can see the story (in Dot language) for the above flow diagram here. I find Dot to be a great language to try to tell a story in, and I find GraphViz to be helpfully unforgiving when my story is too complicated for presentation. I invariably find myself using GraphViz's layout behavior (and occasional recalcitrance when it won't do quite what I want) as a warning for when I'm not telling a story clearly or well, or when I've glossed over details, or when the story is just plain wrong for the goals it's supposed to serve.</p> <p>I render the Dot language content into PNG and SVG, which I save back into the local Git repository, next to the Dot file that generated them.</p>"},{"location":"blog/2018/01/09/blog-workflow/#github-hosts-the-content","title":"GitHub Hosts the Content","text":"<p>My local git repository pushes up to the repository on GitHub, and GitHub maintains a Jekyll setup there to convert the contents of the repository into a bunch of static files. This works more or less OK (troubleshooting is tough at times), but it's free, and it's portable enough for me to take my content wherever I want.</p> <p>Jekyll on GitHub also integrates Google Analytics for me. It's nice to see if anyone's reading what I'm writing.</p>"},{"location":"blog/2018/01/09/blog-workflow/#ifttt-handles-most-of-the-publication","title":"IFTTT Handles (most of) the publication","text":"<p>Jekyll generates an RSS feed, which IFTTT consumes. When new content appears, IFTTT posts to LinkedIn, Twitter, Facebook and Reddit. IFTTT doesn't have direct support for posting to Google+, but it does support adding links to a Buffer queue, and Buffer can post to Google+. So I have Buffer doing a scheduled drain into Google+. It seems to work.</p>"},{"location":"blog/2018/01/09/blog-workflow/#thats-it","title":"That's it","text":"<p>That's it! That's my \"platform.\" The set of tools I use to move content from my head to your eyes. It's not quite as easy as, say, a WordPress install. But it requires a lot less operational support, at least from me. Which is a nice change of pace.</p>"},{"location":"blog/2018/01/12/graphviz-technique-nodes-as-edge-labels/","title":"Nodes as Labels","text":"<p>First, I apologize if I state some obvious things here; Dot and Graphviz operate on a lot of computer science principles, and that's not my background. So I apologize for boring you who already know what I'm talking about.</p> <p>Edges in Dot are connections between nodes. Here's an example of two nodes, <code>A</code> and <code>B</code>, with an edge connecting <code>A-&gt;B</code>: Two nodes labeled A and B. There is a line connecting node A to B, with an arrowhead pointing at node B.](../../../../../assets/graphviz-techniques-nodes-as-edge-labels/node-node/node-node.svg)</p> <p>Here are those same two nodes and an edge, plus an edge label: Two nodes labeled A and B. There is a line connecting node A to B, with an arrowhead pointing at node B. Overlapping the middle of the line begins the string 'A descriptive label'.](../../../../../assets/graphviz-techniques-nodes-as-edge-labels/node-edge-label/node-edge-label.svg)</p> <p>Notice how the string 'A descriptive label' begins with some overlap on the edge? It doesn't look great. Now let's compound the issue by adding two more nodes, and giving all the edges the same label. (This is a common circumstance if, for example, you have something that has the same kind of relationship to several other things, and you want to express what type of relationship that is.)</p> <p></p> <p>Now there isn't quite so much overlap (only <code>A-&gt;</code>C` is vertical, so it winds up more crowded), but all of the edge labels still crowd the edges they label, as well as anything else they crowd out.</p> <p>We can clean this up significantly by, surprisingly enough, adding another node. We'll play with some styling to make it look nice; the node we add won't look like a node.</p> <p></p> <p>What we've done is pointed <code>A</code> at a node that we've given the <code>style</code> of <code>none</code>, so its border disappears, and we've given this node the label that we were previously applying to edges. Then we take this label-node and draw edges to <code>C</code>, <code>D</code> and <code>E</code>.</p> <p>This does two things for us. First and foremost, Graphviz treats only nodes and edges as first-order objects, meaning they get the most attention when developing layout engines, and their placement and behavior are the cleanest and most reliable of all the things that might be drawn. Edge labels and clusters (we'll talk about those in another post) don't get as much love. In some layout engines, edge labels will be drawn, but you'll be shown a warning that edge labels aren't supported. And most layout engines don't support clusters at all!</p> <p>So by using nodes where we might otherwise use edge labels or clusters, we get a more predictable result from Graphviz's layout engine.</p> <p>Second, instead of needing one label for each edge, we can use one label for all edges. That often saves a considerable amount of space in the graph layout, which makes it easier to build large or complex graphs without sacrificing as much readability.</p> <p>Now see what the last post's chart would look like if it used edge labels instead of nodes as labels.</p> <p></p> <p>See how the labels are being drawn over by edges? Granted, I have splines turned off, but it doesn't help to turn them back on, except to get the \"For writing to\" edge drawn where you can see it again:</p> <p></p> <p>Here, labels aren't being drawn over by edges, but they're very crowded. Notices the edge between Graphviz and SVG; it takes a very long route, and it looks very dented as it passes near various other edges and labels; the layout engine had a difficult time finding a clear path.</p> <p>But if we use nodes in place of edge labels, it cleans up nicely:</p> <p></p> <p>The diagram is much taller than previous diagrams, but it's also much narrower. No edge overlaps any label, and there's a clear margin of space between label text and edges, aiding readability. We were also able to use nodes-as-labels to create concentration points; see where <code>Visual Studio Code</code>, <code>SVG</code> and <code>PNG</code> all point to <code>For writing to</code> before moving on to <code>Local git repo</code>? By being able to reuse the same label, we were able to take a great deal of strain off of the layout engine and let it give us a much cleaner result.</p> <p>So, there. A fairly simple technique, but it carries a big impact. May you find it useful!</p>"},{"location":"blog/2018/02/04/graphviz-sh-zsh-bash-refactor/","title":"Sh-Zsh-Bash Chart Refactor","text":"<p>So, on the Grand Rapids Slack team, T.J. Zimmerman shared an interesting chart (originally by Peter Ward, from his blog post here) which showed the behaviors of <code>sh</code>, <code>zsh</code> and <code>bash</code> as they built (and tore down) their environments in each of (non-)remote, (non-)login and (non-)interactive sessions. It was interesting in that it conveyed a huge amount of very useful information, but I was, well, offended that it didn't seem to do so well.</p> <p>I haven't (yet) secured Peter's permission to embed his image here, so you'll have to go look at it in his blog post listed above. But I'll describe my issues with it here.</p> <p>Before I continue, let be clear that he clearly did a huge amount of research building his post (and his charts), and the information he assembled visually is quite valuable. He gets the credit for the research.</p> <p>That said...</p>"},{"location":"blog/2018/02/04/graphviz-sh-zsh-bash-refactor/#concerns","title":"Concerns","text":"<ol> <li>I found the chart to be difficult to process, visually; I'm not in any degree color-blind, but the closely-spaced lines were difficult to follow, and more than once while rebuilding the chart, I followed the wrong branch at one point or another because of the color-coded switchback approach.</li> <li>If you don't read the supporting text around the chart, it's not clear what the <code>/etc/bash.bashrc -&gt; {~/.profile, ~/.bash_profile, ~/.bash_login} -&gt; running</code> construct means; I initially thought it implied each of <code>{~/.profile, ~/.bash_profile, ~/.bash_login}</code> would be consumed in some unclear order, but it turns out that subsequent entries in the list are only consumed if earlier entries aren't found.</li> <li>It's very difficult to follow the flow in reverse; choose a node further down in the chart, and try to walk the chart backwards. Perhaps you'll have an easier time than I did, but I found the edges crowded and the paths complex, especially around the <code>bash</code>-specific paths.</li> </ol> <p>I thought, \"I can do better than this. It won't even take that long.\" Well, it took me over a week of spare cycles at home to get Graphviz to produce something I was satisfied with. I was at least half-wrong, but I certainly learned a lot along the way! And, boy, did it produce a lot of blog fodder.</p>"},{"location":"blog/2018/02/04/graphviz-sh-zsh-bash-refactor/#results","title":"Results","text":"<p>Here's (mostly; I found and fixed a bug or two) the same data as in the original chart, but cleaned up:</p> <p></p> <p>So, again, we're covering each of <code>sh</code>, <code>zsh</code> and <code>bash</code>, with every combination of shell, (non)remote, (non)login and (non)interactive, where the shell supports the distinction. (Only <code>bash</code> recognizes remote shells.)</p>"},{"location":"blog/2018/02/04/graphviz-sh-zsh-bash-refactor/#swimlanes","title":"Swimlanes","text":"<p>The first thing to notice is the use of swimlanes.</p> <p></p> <p>Instead of using a particular-colored line bouncing from file node to file node shared with other colored lines, we use a single swimlane to identify a single combination of session parameters. While this makes the chart decidedly less compact, it reduces a great deal of pressure on the layout engine, letting us do much more tweaking, and giving us the option of packing in more information without the output looking like a tangled mess of spaghetti.</p>"},{"location":"blog/2018/02/04/graphviz-sh-zsh-bash-refactor/#swimlanes-origins-rationale","title":"Swimlanes Origins / Rationale","text":"<p>The use of swimlanes came out of my earlier attempt to reformulate the chart as a truth table. This was before I discovered the special conditional relationships between ~/.profile, ~/.bash_login and ~/.bash_profile. Earlier still, I'd attempted to replace the nodes in the original chart with clusters where each workflow would stop off at a workflow-dedicated node in a cluster corresponding to the file being evaluated. If you're having a difficult time picturing that, don't worry; so did the layout engine&amp;emdash;it gave me a bunch of spaghetti, in large part because it tries to route edges around clusters, rather than through them.</p>"},{"location":"blog/2018/02/04/graphviz-sh-zsh-bash-refactor/#granular-same-rank-association","title":"Granular Same-Rank Association","text":"<p>The columnar behavior is in part because Graphviz thinks of this as a directed graph, but the placement of this or that in a given column comes from using the <code>rank=same</code> attribute in an anonymous subgraph. The syntax looks like this:</p> <pre><code>    {\n        rank=same\n        sh_nn [label=\"Sh\\nNon-Login\\nNon-Interactive\"]\n        sh_ni [label=\"Sh\\nNon-Login\\nInteractive\"]\n        sh_ln [label=\"Sh\\nLogin\\nNon-Interactive\"]\n        sh_li [label=\"Sh\\nLogin\\nInteractive\"]\n    }\n</code></pre> <p>The above code results in all of the session-describing nodes in the same rank (and thus the same column, in this graph). In the following image, the above code is what builds the left-most column.</p> <p></p> <p>If I remove the samerank behavior from all but the Running column, this is the result:</p> <p></p> <p>Note that all of the empty stretches in the swimlanes have collapsed, with everything moving as close to the Running column as its swimlane allows. That's obviously much less clear than having the swimlane labels lined up, with empty space where a swimlane doesn't have a function in common with any other swimlane.</p> <p>The other thing interesting about this approach is that while the above nodes will be in the same rank, we're not forcing them to be the only things in that rank.</p> <p>Let's return to the samerank behavior:</p> <p></p> <p>Now let's add a a few new nodes and edges, and another samerank grouping. This is largely the same as the above image, but I've de-emphasized (by making them dashed lines) the swimlane edges, emphasized the samerank groupings (by adding visible lines where there weren't any, and making all lines thick and solid), and made the nodes part of each grouping a different shape and color.</p> <p></p> <p>The set of black nodes and edges are held in place with two constraints; the <code>A -&gt; B -&gt; C -&gt; D</code> row has as many ranks as the entire graph, so it extends end to end. The three black circles labeled \"B\" are held together via a <code>rank=same</code> directive, which is why the <code>B -&gt; C</code> line is in the middle of the graph, occupying neither the first or fourth ranks.</p> <p>Now, the set of nodes labeled \"B\" are interesting, because they occupy the same rank as the set of nodes labeled \"~/.profile\". Just because you set two different sets of nodes as <code>rank=same</code> doesn't mean each set of nodes they'll occupy the same rank, but it doesn't mean they'll occupy different ranks, either.</p> <p>This helps us avoid the use of column headers, since we're able to reuse the same column for multiple groups of data, so long as those groups aren't in the same swimlane.</p>"},{"location":"blog/2018/02/04/graphviz-sh-zsh-bash-refactor/#ranksame-origins-rationale","title":"<code>rank=same</code> Origins / Rationale","text":"<p>I originally tried to use common nodes, and then clusters, to group common points in the different workflows, but I invariably wound up with spaghetti flows. When you use clusters, Graphviz will try to pull the nodes in a cluster into the smallest possible space, distorting the graph outside of the cluster. However, the anonymous subgraph using <code>rank=same</code> doesn't have that distorting effect; it only forces nodes into a given rank.</p> <p>The more I used constraining tools like clusters and edges with <code>[constraint=true]</code> (which is the default), the harder it became to avoid spaghetti. I felt like the Emperor; the tighter I gripped, the more slipped through my grasp. The more I relaxed, the easier it became.</p>"},{"location":"blog/2018/02/04/graphviz-sh-zsh-bash-refactor/#eye-guiding-non-constraining-lines","title":"Eye-Guiding, Non-Constraining Lines","text":"<p>Look for the small vertical dotted lines in this subset of the larger graph:</p> <p></p> <p>Each of these dotted lines are within a <code>rank=same</code> grouping, and they help draw your eye along that rank in order to identify the grouped elements. Since we group elements of the same or similar roles, that helps you identify those roles as groupings without being too distracting from the swimlanes.</p>"},{"location":"blog/2018/02/04/graphviz-sh-zsh-bash-refactor/#eye-guide-origins-rationale","title":"Eye-guide Origins / Rationale","text":"<p>Without the clear bounding boxes offered by clusters, I wanted a way to get visible groupings. Drawing non-constraining lines provided that. A dotted line is less distracting from the swimlanes than a solid line would be.</p>"},{"location":"blog/2018/02/04/graphviz-sh-zsh-bash-refactor/#colors","title":"Colors","text":"<p>Let's look at our chart without colors:</p> <p></p> <p>It's...readable, but not easily. Try reading the Sh, Non-Login, Non-Interactive line. Your eye may well jump lanes down to the interactive swimlane below as you try to trace the line. That's not great. While the graph is still clear and accurate, some color for contrast would be useful. To help with that, I used four distinct colors for the chart, one per swimlane:</p> <p></p> <p>Each color is keyed off of whether or not a swimlane corresponds to a login session, and whether or not a swimlane corresponds to an interactive session. The four colors are drawn from a colorblind-safe palette.</p>"},{"location":"blog/2018/02/04/graphviz-sh-zsh-bash-refactor/#colors-origins-rationale","title":"Colors Origins / Rationale","text":"<p>I'm not fond of using color for encoding information without an alternate way to present that same information; colorblindness is a real thing, and keying information off of color can make the chart more difficult to read. The chart that inspired this one relied on color as the sole way of distinguishing program flow, and was difficult to follow, as a result.</p> <p>Colors should be used for accenting and supplementing information, not as a primary differentiator; this is called redundant coding. (Instead of using different shapes, I use spacial separation of swimlanes and clear labels for my primary indicators. That said, the black-and-white version might be able to take advantage of more mechanisms. I'm pleased enough with the colorblind-safe palette, though.)</p> <p>Here is a very good resource for considering how to present data with consideration of colorblindness. It also contains the palette of colors I drew from for this chart.</p>"},{"location":"blog/2018/02/04/graphviz-sh-zsh-bash-refactor/#html-like-labels-for-choices","title":"HTML-like labels for Choices","text":"<p>The original chart had choices presented in it, but it wasn't clear that that's what they were unless you read the supporting text. Here, we use HTML-like labels in order to use tables to get us nodes with multiple inputs and outputs. This lets us label a path without using edge labels.</p> <p></p> <p>Notice the boxes for <code>~/.profile</code> and <code>~/.bash_login</code>. See how flow passes into the box at the cell labeled after the file in question, and flow leaves the box through cells labeled \"Found\" and \"Not found\", with lines drawn to wherever flow moves next. These are HTML-like labels, specifically taking advantage of tables and ports. The Dot language doesn't actually implement HTML, nor does it fully implement HTML tables. It does, however, extend tables with ports; you can add a <code>port=\"some_string\"</code> attribute to a <code>td</code> element in an HTML-like label, and then address that specific port when drawing edges, using syntax like <code>node1:my_port -&gt; node2:my_other_port</code>, or even <code>node1:port1 -&gt; node1:port2</code></p> <p>Here's the source code for the above swimlane. See if you can identify where the ports are created, and where they're used in the edges.</p> <pre><code>digraph {\n    node [label=\"\\N\" shape=none]\n    edge [style=dotted constraint=false dir=none]\n    rankdir=LR\n\n    bash_nli [label=\"Bash\\nNon-Remote\\nLogin\\nInteractive\"]\n    bash_nli_etc_profile [label=\"/etc/profile\"]\n    bash_nli_home_bash_login_case  [label=&lt; &lt;table border='0' cellborder='1' cellspacing='0'&gt;&lt;tr&gt;&lt;td rowspan='2' port='in'&gt;~/.bash_login&lt;/td&gt;&lt;td port='found'&gt;Found&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td port='not_found'&gt;Not found&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; &gt; shape=none]\n    bash_nli_home_bash_profile [label=\"~/.bash_profile\"]\n    bash_nli_running_to_logout [label=\"Running...\"]\n    bash_nli_logout [label=\"~/.bash_logout\"]\n    bash_nli_home_profile_case [label=&lt; &lt;table border='0' cellborder='1' cellspacing='0'&gt;&lt;tr&gt;&lt;td rowspan='2' port='in'&gt;~/.profile&lt;/td&gt;&lt;td port='found'&gt;Found&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td port='not_found'&gt;Not found&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; &gt; shape=none]\n\n    edge [color=\"#009e73\" penwidth=5 constraint=true style=solid dir=forward]\n\n    bash_nli -&gt; bash_nli_etc_profile -&gt; bash_nli_home_profile_case:in\n    bash_nli_home_bash_login_case:found -&gt; bash_nli_running_to_logout\n    bash_nli_home_bash_login_case:not_found -&gt; bash_nli_home_bash_profile -&gt; bash_nli_running_to_logout\n    bash_nli_home_profile_case:found -&gt; bash_nli_running_to_logout\n    bash_nli_home_profile_case:not_found -&gt; bash_nli_home_bash_login_case:in\n    bash_nli_running_to_logout -&gt; bash_nli_logout\n}\n</code></pre>"},{"location":"blog/2018/02/04/graphviz-sh-zsh-bash-refactor/#html-like-labels-for-choices-origins-rationale","title":"HTML-like labels for Choices Origins / Rationale","text":"<p>I'd actually completed the chart using a very different style before I realized I was missing the choices, and rewrote the chart to identify the decision points. To label the decision points, I tried using cluster, nodes as labels, nodes-as-labels with some deliberate coalescing of shortcut paths...I even tried using edge labels. I couldn't make the chart come out clean. Finally, I tried using HTML labels with ports, and it gave me a result compact enough to make a chart that worked and didn't have edge spaghetti everywhere.</p> <p>The big advantage to using HTML-like labels and tables, in this case, is that the layout engine treats the entire label as a single node, for the purpose of placing nodes. That makes ranking much easier to manage, as a single piece of information doesn't have to spread across multiple ranks; I had tried using both <code>rank=same</code> and clusters to contain that problem, and I simply wound up with more edge spaghetti as the layout engine either chose strange circumlocutious paths for edges, or tried running edges around clusters in ways that made edges difficult to distinguish from each other. Ultimately, being able to pack all of that information cleanly into the boundary of a single node let me build a much cleaner graph.</p>"},{"location":"blog/2018/02/04/graphviz-sh-zsh-bash-refactor/#same-rank-constraining-edges","title":"Same-rank, Constraining Edges","text":"<p>Notice how there's a very definite sequence to the ordering of the swimlanes?</p> Shell Remote Login Interactive Sh N/A No No Sh N/A No Yes Sh N/A Yes No Sh N/A Yes Yes Zsh N/A No No Zsh N/A No Yes Zsh N/A Yes No Zsh N/A Yes Yes Bash No No No Bash No No Yes Bash No Yes No Bash No Yes Yes Bash Yes No No Bash Yes No Yes Bash Yes Yes No Bash Yes Yes Yes <p>That sequence was maintained by using a constraining edge on each of the <code>Running...</code> nodes:</p> <pre><code>    {\n        rank=same\n        edge [constraint=true]\n        node [label=\"Running...\"]\n        sh_nn_running -&gt;\n        sh_ni_running -&gt;\n        sh_ln_running -&gt;\n        sh_li_running -&gt;\n        zsh_nn_running -&gt;\n        zsh_ni_running -&gt;\n        zsh_ln_running -&gt;\n        zsh_li_running -&gt;\n        bash_nnn_running -&gt;\n        bash_nni_running -&gt;\n        bash_nln_running -&gt;\n        bash_nli_running -&gt;\n        bash_rnn_running -&gt;\n        bash_rln_running -&gt;\n        bash_rli_running\n    }\n</code></pre> <p>This told the layout engine that there was a deliberate ordering there, and the layout engine sought to maintain it. Here's what the graph looks like without that constraining edge:</p> <p></p> <p>Note that Zsh floated to the top, and the Sh swimlanes are split to both before and after the Bash swimlanes. You can even see how some of the dotted lines are no longer simply vertical; they have to jump over other nodes in the same rank in order to reach the rest of their group. There's a reason it's ordered like that, but I don't understand it well enough to tell you how to predict it.</p> <p>There is one other constraining samerank edge in the graph, though:</p> <pre><code>        edge [constraint=true style=invis]\n        bash_rnn -&gt; bash_rni -&gt; bash_rln\n</code></pre> <p>If you look at the swimlane for Bash/Remote/Non-Login/Interactive, you'll notice is't quite short. In fact, it goes straight to \"No path\", and doesn't reach the Running state. Since the Running state is where we're applying all of our samerank edge constraints, this particular swimlane doesn't get picked up by it. So we anchor it to its neighbors (Bash/Remote/Non-Login/Non-Interactive and Bash/Remote/Login/Non-Interactive) in order to control its vertical placement. If we didn't, it would float to the top of the chart, and would be nowhere near the rest of the Bash swimlanes!</p>"},{"location":"blog/2018/02/10/hardware-touchpad-troubles/","title":"Touchpad troubles","text":"<p>So, my Lenovo Yoga 13 has always had trouble with its touchpad. Previously, on a cold boot, the touchpad wouldn't work. Simply suspending and resuming the laptop would be enough to make it work, so it wasn't a huge concern.</p> <p>With the latest round of updates, though, now the touchpad doesn't work at all, and I'm left with using either the touchscreen or some external device for a mouse. Nothing I've tried has managed to bring back my touchpad, and I'm suspecting it's not even showing up under <code>lsusb</code> any more...but I'm not even sure what's supposed to show up for this hardware; it's never been a popular model among Linux users.</p> <p>Any suggestions welcome.</p> <p>Here's some of the output of <code>dmidecode</code>:</p> <pre><code>System Information\n Manufacturer: LENOVO\n Product Name: Mocca 2.0\n Version: Lenovo Ideapad YOGA 13\n Wake-up Type: Power Switch\n SKU Number: LENOVO_BI_IDEAPAD66\n Family: IDEAPAD\n</code></pre> <p>Here's the output of <code>lsusb</code>:</p> <pre><code>Bus 002 Device 004: ID 04f2:b322 Chicony Electronics Co., Ltd \nBus 002 Device 003: ID 2047:0855 Texas Instruments Invensense Embedded MotionApp HID Sensor\nBus 002 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub\nBus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\nBus 001 Device 005: ID 04f3:000a Elan Microelectronics Corp. Touchscreen\nBus 001 Device 004: ID 0bda:1724 Realtek Semiconductor Corp. RTL8723AU 802.11n WLAN Adapter\nBus 001 Device 003: ID 0bda:0129 Realtek Semiconductor Corp. RTS5129 Card Reader Controller\nBus 001 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub\nBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\nBus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub\nBus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\n</code></pre> <p>Here's the output of <code>lsusb -t</code>:</p> <pre><code>/:  Bus 04.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/4p, 5000M\n/:  Bus 03.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/4p, 480M\n/:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=ehci-pci/2p, 480M\n    |__ Port 1: Dev 2, If 0, Class=Hub, Driver=hub/8p, 480M\n        |__ Port 5: Dev 3, If 0, Class=Human Interface Device, Driver=usbhid, 12M\n        |__ Port 7: Dev 4, If 0, Class=Video, Driver=uvcvideo, 480M\n        |__ Port 7: Dev 4, If 1, Class=Video, Driver=uvcvideo, 480M\n/:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=ehci-pci/2p, 480M\n    |__ Port 1: Dev 2, If 0, Class=Hub, Driver=hub/6p, 480M\n        |__ Port 3: Dev 3, If 0, Class=Vendor Specific Class, Driver=rtsx_usb, 480M\n        |__ Port 4: Dev 4, If 1, Class=Wireless, Driver=btusb, 480M\n        |__ Port 4: Dev 4, If 2, Class=Vendor Specific Class, Driver=rtl8xxxu, 480M\n        |__ Port 4: Dev 4, If 0, Class=Wireless, Driver=btusb, 480M\n        |__ Port 5: Dev 5, If 0, Class=Human Interface Device, Driver=usbhid, 12M\n</code></pre> <p>(The content for this post was lost somehow. So this is a total rewrite. It's bizarre, because I thought I viewed it on the live site. Ah well. This is what unit tests are for. Suppose I'll need to figure out unit tests for my blog, like _there's content in every file under <code>_posts_</code>! ... Actually, that's not a bad idea. Could possibly even validate that all the links and embedded resources work...I'm doing a <code>git</code> workflow for my blog, so why not?)</p>"},{"location":"blog/2018/02/11/color-safe-palette/","title":"A Color-Safe Palette","text":"<p>So, while I've been using this colorblind palette by Masataka Okabe and Kei Ito, the palette is presented only as a screenshot; I can't copy/paste values. Worse, it doesn't come with hex values, which are what I'm most likely to need. So here's that same palette presented as a pair of tables, one with decimal values for channel percentages, and one with with decimal (0-255 range), hex and combined-hex values.</p>"},{"location":"blog/2018/02/11/color-safe-palette/#percentages-rgb-cmyk","title":"Percentages RGB, CMYK","text":"Color Name R G B C M Y K  black  0 0 0 0 0 0 100  orange  90 60 0 0 50 100 0  sky blue  35 70 90 80 0 0 0  bluish green  0 60 50 95 0 75 0  yellow  95 90 25 10 5 90 0  blue  0 45 70 100 50 0 0  vermilion  80 40 0 0 80 100 0  reddish purple  80 60 70 10 70 0 0"},{"location":"blog/2018/02/11/color-safe-palette/#0-255-range-hex-and-combined-hex","title":"0-255 Range, Hex and Combined-hex","text":"Color Name R G B hex(R) hex(G) hex(B) combined  black  0 0 0 00 00 00 #000000  orange  230 159 0 E6 9F 00 #E69F00  sky blue  86 180 233 56 B4 E9 #56B4E9  bluish green  0 158 115 00 9E 73 #009E73  yellow  240 228 66 F0 E4 42 #F0E442  blue  0 114 178 00 72 B2 #0072B2  vermilion  213 94 0 D5 5E 00 #D55E00  reddish purple  204 121 167 CC 79 A7 #CC79A7"},{"location":"blog/2018/02/13/asset-regeneration-script/","title":"Asset regeneration script","text":"<p>So, in the interest of trying to be lazy (really!), I wrote a script to automate the generation of graphic assets from the <code>dot</code> source files. It does a few things for me:</p> <ul> <li>It only generates files that have been updated (with similar behavior to <code>make</code>; it only updates assets if the source file is newer than the asset).</li> <li>It generates both PNG and SVG files (and could generate any format <code>dot</code> supports).</li> <li>It quantizes and crushes PNG assets, drastically reducing file size.</li> <li>It commits modified source files to avoid losing work (a generated asset is a conscious effort. I presume it represents a significant change in the source.)</li> <li>It commits generated assets.</li> <li>It saves me manually typing the <code>dot</code> commands or relying on shell history to keep them.</li> </ul>"},{"location":"blog/2018/02/13/asset-regeneration-script/#workflow","title":"Workflow","text":"<p>Here's how it works:</p> <ol> <li>Find all <code>dot</code> files in my <code>assets</code> folder.</li> <li>For each <code>dot</code> file<ol> <li>For each format (I specify SVG and PNG)<ol> <li>Check to see if the <code>dot</code> file is newer than the corresponding PNG or SVG.<ol> <li>If it's newer:<ol> <li>Commit the <code>dot</code> file to the <code>git</code> repository, in case the work-in-progress hasn't been committed already.</li> <li>Render the asset</li> <li>If the asset is a PNG:<ol> <li>Force the PNG into indexed RGBA mode using <code>pngquant</code>; for many images, this grossly reduces the PNG file size.</li> <li>Run <code>pngcrush</code> on the indexed PNG, trying all strategies that use the maximum Zlib compression. For PNG images which <code>pngquant</code> didn't make a significant file size dent in, this will.</li> </ol> </li> <li>Stage the asset for commit.</li> </ol> </li> </ol> </li> </ol> </li> <li>If there are changes staged for commit, commit them.</li> </ol> </li> </ol>"},{"location":"blog/2018/02/13/asset-regeneration-script/#source","title":"Source","text":"<pre><code>#!/bin/bash\nfmts=\"svg png\"\nbanned_branches=\"master regen-assets\"\n\ncurrent_branch=$(git branch -l | grep -e '^*' | cut -d' ' -f2)\n\nfor b in ${banned_branches} ; do\n    if [[ \"${current_branch}\" == \"${b}\" ]]; then\n        echo \"Not regenerating assets. ${b} is a protected branch.\"\n        exit 1\n    fi\ndone\n\ngit_status=$(git status)\n\nif echo \"${git_status}\" | grep \"Changes to be committed\" &gt; /dev/null ; then\n    echo \"Not regenerating assets. You have staged, uncommitted changes.\"\n    exit 1\nfi\n\nwhile IFS= read -r -d '' dotfile ; do\n    assetdir=$(dirname \"${dotfile}\")\n    assetname=$(basename \"${assetdir}\")\n    echo \"Generating renders for $(basename ${assetdir})\"\n    for fmt in ${fmts} ; do\n        dstfile=\"${assetdir}/${assetname}.${fmt}\"\n        if [[ \"${dotfile}\" -nt \"${dstfile}\" ]] ; then\n            echo \"${dotfile} has been updated. Committing $dotfile\"\n            git commit --quiet -m \"Caught uncommited changes to ${assetname}. Preserving separately.\" \"${dotfile}\"\n            echo \"Building ${fmt} for $(basename ${assetdir})\"\n            dot \"-T${fmt}\" -o \"${assetdir}/${assetname}.${fmt}\" \"${dotfile}\"\n            if [[ $fmt == \"png\" ]] ; then\n                orig_size=$(stat -c %s \"${dstfile}\")\n                pngquant --force --ext .png -Q 100-100 \"${dstfile}\"\n                quant_size=$(stat -c %s \"${dstfile}\")\n                pngcrush -ow -brute -l 9 -q \"${dstfile}\"\n                crushed_size=$(stat -c %s \"${dstfile}\")\n                echo \"Original: ${orig_size}b. Quantized: ${quant_size}b. Crushed: ${crushed_size}\"\n            fi\n            echo \"Adding ${dstfile}\"\n            git add \"${dstfile}\"\n        fi\n        echo \"checking for changes\"\n        if git status | grep \"Changes to be committed\" &gt; /dev/null ; then\n            echo \"Committing changes for ${assetname}\"\n            git commit --quiet -m \"Preserving binary renders for ${assetname}\"\n        fi\n    done\ndone &lt; &lt;(find assets -type f -name '*.dot' -print0)\n</code></pre> <p>Pretty handy. We'll have to see how automating munging of my <code>git</code> repo works out, but I think there's going to be more value in automating it than is lost digging through some strange git history. At least the visual renders will accompany the various versions of the dotfiles, so understanding the impacts of changes will be easier, and I'll have snapshots of works-in-progress to go back to illustrate _why__ I took one approach or another while demonstrating more about Dot and Graphviz.</p>"},{"location":"blog/2018/02/18/link-rollup/","title":"Link Rollup 2018-02-15","text":"<p>So, the first (probably)-weekly link rollup. Rather than say \"oh, cool, look at this!\" for everything I spot that I think is useful or interesting, I'll just drop the link in a queue and flush the queue as a single post later.</p> <p>So...</p>"},{"location":"blog/2018/02/18/link-rollup/#redirect-in-response-to-post-transaction","title":"Redirect in response to POST transaction","text":"<p>I'm designing a new API, documenting each endpoint's responses meanings, and I found myself with that exact question.</p>"},{"location":"blog/2018/02/18/link-rollup/#openapi-specification","title":"OpenAPI Specification","text":"<p>Like I said. Designing a new API. Now, I'm a big fan of JSON-SCHEMA, and OpenAPI is an extension (with some backward-incompatible adjustments) of that. I'll probably still look at JSON-SCHEMA for record formats, data-at-rest; OpenAPI's ability to <code>{$ref}</code> over to a JSON-SCHEMA schema for parameter and response object structures means I can encode data structure validation end-to-end from the database through the API all the way to the client's understanding of the data structure. That's fantastic.</p> <p>(Now, are there any databases that support applying JSON-SCHEMA schemas to value formats? Or am I going to have to stuff a thin OpenAPI wrapper around <code>etcd</code> and <code>redis</code> to achieve that? Hm. Has me thinking about how to handle schema changes. There's another fun problem space to noodle on.)</p>"},{"location":"blog/2018/02/26/graphviz-dot-basics-pt-1/","title":"Dot Language Basics Pt 1: Nodes, Edges and Simple Undirected Graphs","text":"<p>I was asked to do a piece on the basics of Graphviz. I'm going to assume you can find a way to access the software; anything I say here will be out of date soon enough. So I'm going to talk about the Dot language itself, and how a handful of simple graphs behave in different layout engines.</p>"},{"location":"blog/2018/02/26/graphviz-dot-basics-pt-1/#graphviz-and-dot-are-different-things","title":"Graphviz and Dot are Different Things","text":"<p>No, they really are. Just like <code>cc</code> and the C language are different things, so are Graphviz and Dot. Graphviz is a distribution of programs that implement (and extend) the Dot language.</p>"},{"location":"blog/2018/02/26/graphviz-dot-basics-pt-1/#a-simple-undirected-graph","title":"A simple undirected graph","text":"<p>Wait, first, what's a graph? A graph is a set of nodes connected by edges. That's it. Here's an example:</p> <pre><code>graph {\n    a -- b\n}\n</code></pre> <p>So you see two nodes, named <code>a</code> and <code>b</code>, and the two nodes are connected by a single edge.</p> <p></p> <p>To create a node in Dot, all you need to do is mention it by name. This can be on its own, or while declaring an edge. So, this graph is identical to the above:</p> <pre><code>graph {\n    a\n    b\n    a -- b\n}\n</code></pre> <p></p> <p>This also happens to be an acyclic graph, which means there is only one path between any two nodes in the graph. It's trivial to make this into a cyclic graph:</p> <pre><code>graph {\n    a -- b\n    a -- b\n}\n</code></pre> <p></p> <p>Now there are two edges between the same two nodes. Since there's more than one path between the two nodes, the graph is no longer acyclic. But drawing two edges directly between the same two nodes feels like cheating to illustrate the concept, so here's another example of a simple cyclic graph:</p> <pre><code>graph {\n    a -- b -- c -- a\n}\n</code></pre> <p></p> <p>Now we have three nodes, <code>a</code>, <code>b</code>. <code>c</code>, and they form a loop. If you choose a node and follow the edges, you can (inevitably will, in this case) eventually wind up where you started. Since there's more than two paths between a pair of nodes, this graph is said to be cyclic.</p> <p>For our purposes, we don't usually care about whether a graph is cyclic or acyclic, but Graphviz can occasionally get confused with directed cyclic graphs. More on that (well, directed graphs) later.</p>"},{"location":"blog/2018/02/27/graphviz-dot-basics-pt-2/","title":"Dot Language Basics Pt 2: Layout Engines, Clusters and Complicated Undirected Graphs","text":"<p>So, we covered simple, undirected graphs. Let's look at a couple more complicated cases, one with clustering and one without, so we can explore layout engines.</p> <pre><code>graph {\n    A [style=\"filled\" fillcolor=\"#F0E442\" color=\"#E69F00\" penwidth=8]\n    B [style=\"filled\" fillcolor=\"#F0E442\" color=\"#009E73\" penwidth=8]\n    C [style=\"filled\" fillcolor=\"#F0E442\" color=\"#CC79A7\" penwidth=8]\n    D [style=\"filled\" fillcolor=\"#56B4E9\" color=\"#E69F00\" penwidth=8]\n    E [style=\"filled\" fillcolor=\"#56B4E9\" color=\"#009E73\" penwidth=8]\n    F [style=\"filled\" fillcolor=\"#56B4E9\" color=\"#CC79A7\" penwidth=8]\n    G [style=\"filled\" fillcolor=\"#D55E00\" color=\"#E69F00\" penwidth=8]\n    H [style=\"filled\" fillcolor=\"#D55E00\" color=\"#009E73\" penwidth=8]\n    I [style=\"filled\" fillcolor=\"#D55E00\" color=\"#CC79A7\" penwidth=8]\n\n    A -- B\n    B -- C\n    C -- A\n\n    D -- E\n    E -- F\n    F -- D\n\n    G -- H\n    H -- I\n    I -- G\n\n    A -- D\n    B -- G\n    H -- E\n}\n</code></pre> <p>Remember, this is a cyclic graph; within the graph, there exist two nodes which have more than one path to reach each other. In fact, it's pretty easy to identify three cyclic subgraphs within the larger graph; <code>A-B-C</code>, <code>D-E-F</code> and <code>G-H-I</code>, and these smaller subgraphs are connected to each other. For visualizations' sake, I've added color information to each node, so the nodes will be easier to identify. Since we're dealing with three sets of three nodes, I've color-coded each node based on both which grouping it's part of, and which member of which grouping it is.</p> <p>Now let's consider how we might draw attention to those subgraphs in the Dot language, by wrapping them up with clusters:</p> <pre><code>graph {\n    A [style=\"filled\" fillcolor=\"#F0E442\" color=\"#E69F00\" penwidth=8]\n    B [style=\"filled\" fillcolor=\"#F0E442\" color=\"#009E73\" penwidth=8]\n    C [style=\"filled\" fillcolor=\"#F0E442\" color=\"#CC79A7\" penwidth=8]\n    D [style=\"filled\" fillcolor=\"#56B4E9\" color=\"#E69F00\" penwidth=8]\n    E [style=\"filled\" fillcolor=\"#56B4E9\" color=\"#009E73\" penwidth=8]\n    F [style=\"filled\" fillcolor=\"#56B4E9\" color=\"#CC79A7\" penwidth=8]\n    G [style=\"filled\" fillcolor=\"#D55E00\" color=\"#E69F00\" penwidth=8]\n    H [style=\"filled\" fillcolor=\"#D55E00\" color=\"#009E73\" penwidth=8]\n    I [style=\"filled\" fillcolor=\"#D55E00\" color=\"#CC79A7\" penwidth=8]\n\n    subgraph clusterA {\n        A -- B\n        B -- C\n        C -- A\n    }\n\n    subgraph clusterB {\n        D -- E\n        E -- F\n        F -- D\n    }\n\n    subgraph clusterC {\n        G -- H\n        H -- I\n        I -- G\n    }\n\n    A -- D\n    B -- G\n    H -- E\n}\n</code></pre> <p>Let's see how Graphviz handles these two very similar graphs, using the default <code>dot</code> layout engine:</p> Clustered Non-clustered <p>Notice how in both the clustered and non-clustered cases, <code>A-B-C</code> is near the top of the graph, <code>D-E-F</code> is near the bottom, and <code>G-H-I</code> is near the middle of the graph. However, in the clustered case, each of the three groups are much more compact.</p> <p>Let's look at some other layout engines.</p>"},{"location":"blog/2018/02/27/graphviz-dot-basics-pt-2/#circo-layout-engine","title":"<code>circo</code> Layout Engine","text":"<p>The <code>man</code> page description for <code>circo</code> is quite a mouthful, and reads:</p> <p><code>circo</code> draws graphs using a circular layout (see Six and  Tollis,  GD  '99  and ALENEX  '99, and Kaufmann and Wiese, GD '02. The tool identifies biconnected components and draws the nodes of the component on a  circle. The  block\u2010cut\u2010 point tree is then laid out using a recursive radial algorithm. Edge crossings within a circle are minimized by placing as many edges on the circle's perimeter as possible. In particular, if the component is outerplanar, the component will have a planar layout.</p> <p>If a node belongs to multiple non\u2010trivial biconnected components, the layout puts the node in one of them. By default, this is the first non\u2010trivial component found in the search from the root component.</p> <p>Here's what that means in practice for these graphs:</p> Clustered Non-clustered <p>The first thing you'll notice is that both renders look identical; the <code>cluster</code> keyword is not part of the Dot language itself, and so whether or not it does anything depends on the layout engine.</p> <p>You can see the circle, and if you look, you can find the small subgraphs, but they're not obvious. Notice <code>circo</code> did not choose to place the <code>A</code> node next to the <code>D</code> node, even though that would have resulted in shorter edges and a cleaner result. When Graphviz does that sort of thing, it usually means that placement of nodes is somehow dependent on the listing order of the nodes in the source file itself, and you can usually get the result you're looking for by reordering the content in the source file.</p>"},{"location":"blog/2018/02/27/graphviz-dot-basics-pt-2/#fdp-layout-engine","title":"<code>fdp</code> Layout Engine","text":"<p>The <code>man</code> page description for <code>fdp</code> is brief:</p> <p><code>fdp</code> draws undirected graphs using a ``spring'' model. It relies  on  a  force\u2010directed  approach  in  the  spirit of Fruchterman and Reingold (cf. Software\u2010Practice &amp; Experience 21(11), 1991, pp. 1129\u20101164).</p> <p>Here's what that means for these graphs:</p> Clustered Non-clustered <p>The clustered version of this graph looks very fine in <code>fdp</code>; the graph isn't quite as compact as it could be, but the clusters, at least, highlight the structure of the graph, and are themselves close to each other. The non-clustered version of this graph, however, has no obvious structure; the <code>A-B-C</code> triad overlaps the <code>G-H-I</code> triad, and looks like a mess.</p>"},{"location":"blog/2018/02/27/graphviz-dot-basics-pt-2/#neato-layout-engine","title":"<code>neato</code> Layout Engine","text":"<p>The <code>man</code> page description for <code>neato</code> is also brief:</p> <p><code>neato</code>  draws  undirected graphs using ``spring'' models (see Kamada and Kawai, Information Processing Letters 31:1, April 1989).</p> <p>This doesn't tell you much, but the results speak for themselves:</p> Clustered Non-clustered <p>The first thing you should notice: There's no difference between the clustered and non-clustered versions. Just the same, you can very clearly see all three cyclic subgraphs, they're well-spaced from each other, and their interconnections are very clear. The <code>neato</code> layout engine is very well-suited to this graph, clusters or no.</p>"},{"location":"blog/2018/02/27/graphviz-dot-basics-pt-2/#patchwork-layout-engine","title":"<code>patchwork</code> Layout Engine","text":"<p>The <code>man</code> page description for <code>patchwork</code> describes something different:</p> <p>patchwork draws the graph as a squarified  treemap  (see  M.  Bruls  et  al., \"Squarified treemaps\", Proc. Joint Eurographics and IEEE TCVG Symp. on Visualization, 2000, pp. 33-42). The clusters of the graph are used to  specify  the tree.</p> Clustered Non-clustered <p>All edge information appears to have been lost in this render. That said, compare the clustered and non-clustered versions. In the clustered version, you can clearly see <code>A-B-C</code> grouped, <code>D-E-F</code> grouped, and <code>G-H-I</code> grouped. This behavior is called treemapping.</p>"},{"location":"blog/2018/02/27/graphviz-dot-basics-pt-2/#twopi-layout-engine","title":"<code>twopi</code> Layout Engine","text":"<p>The <code>man</code> page description for <code>twopi</code> describes it as:</p> <p>twopi draws graphs using a radial layout (see G.  Wills,  Symposium  on  Graph Drawing  GD'97, September, 1997).  Basically, one node is chosen as the center and put at the origin.  The remaining nodes are placed on a sequence  of  con centric  circles  centered about the origin, each a fixed radial distance from the previous circle.  All nodes distance 1 from the center are placed  on  the first  circle; all nodes distance 1 from a node on the first circle are placed on the second circle; and so forth.</p> Clustered Non-clustered <p>Unfortunately, this doesn't work well for this graph. If I had to guess, I'd suspect it's largely because the structure of the graph has symmetry; the layout engine is having a hard time finding a node that's meaningful. There are ways we could help it; you can specify the center node, for example, and you can create invisible nodes and edges. Invisible nodes and edges are quite useful on their own, and we'll cover those in another post.</p>"},{"location":"blog/2018/03/24/vdi-and-containers/","title":"VDI and Containers","text":"<p>The more I dig into containers, the more I'm convinced they should be used to implement VDI. An easy start would be to use a single container for the entire login session, accessed using a thin client running X or RDP.</p> <p>Then, it would be interesting to see how much work is needed to make the various IPC mechanisms container-transparent. Unix domain sockets. IP connections to <code>localhost</code>. Shared memory.</p> <p>Shared memory is probably the hardest, but some work has already been done there; Linux already has some code for live-migrating virtual machine's memory and block storage between hosts, and it'd be interesting to see how that work could be translated to sharing state for IPC mechanisms. You might be able to drive it using memory barrier instructions, similar to how VMWare did CPU virtualization before hardware-accelerated virtualization was a thing on PCs. You'd only want to trap membar instructions if executed by processes that have remote-memory file descriptors open, and there'd need to be some work to track what those are...</p> <p>Sounds like fun.</p>"},{"location":"blog/2020/06/14/on-github-actions-security-controls/","title":"On GitHub Actions Security Controls","text":"<p>As I write this, GitHub Actions are still in beta, which is probably a good thing. To understand where I'm coming from, understand that much of my day job is currently figuring out how to engineer automated CI and CD pipelines. I must presume an auditor will inspect my process and automation, and insist I anticipate significant lapses in judgment--or even active malice--in my processes' inputs.</p> <p>I won't presume to try to write a full security review of GHA; I'm not that deep into the field, and I haven't studied GHA that closely. I'm also not going to try to explain GHA in detail. That's what their documentation is for, and I'm sure someone will put together an online course on it. Bully for them!</p> <p>Let's dig in.</p>"},{"location":"blog/2020/06/14/on-github-actions-security-controls/#the-goods-on-github-actions","title":"The goods on GitHub Actions","text":"<p>GitHub Actions steps are defined using references to specific points in the history of other <code>git</code> repositories. That's great because you can lean on <code>git</code>'s intrinsic integrity and traceability assurances; Merkle trees are fantastic.</p> <p>GitHub Actions pipelines are defined entirely within <code>git</code> repo state. That's good; that means that whatever your controls and processes are that govern your source code can be trivially extended to govern the automation that processes your code.</p>"},{"location":"blog/2020/06/14/on-github-actions-security-controls/#the-bad","title":"The bad","text":"<p>However, defining the pipelines entirely within the <code>git</code> repository your source code exists within can be troublesome, too; consider that--for whatever reason--you may have varying trust levels of people with <code>write</code> access to your <code>git</code> repository. You trust as fully as you trust anyone, while others can't be trusted not to repurpose credentials or resources inappropriately in a pinch.</p> <p>In other pipeline tools like Concourse-CI or Jenkins, you can deal with this by filtering jobs out by controlling which branches get considered for work. It's sort of there with GitHub Actions, except the control point is present in the very same <code>git</code> commit as workflow code that may or may not get executed.</p> <p>That means that a foolish actor can modify both the automation actions and the instructions on whether or not to perform those actions in the same feature branch, even the same commit. As a control point, it's not helpful.</p>"},{"location":"blog/2020/06/14/on-github-actions-security-controls/#the-ugly","title":"The ugly","text":"<p>GitHub tried to work around some of these issues by adding a new <code>workflow</code> scope to their OAuth token. However, it causes all kinds of issues:</p> <ul> <li>https://github.com/gitextensions/gitextensions/issues/4916#issuecomment-557509451</li> <li>https://github.com/desktop/desktop/issues/6526</li> <li>https://github.com/github/VisualStudio/issues/2455</li> <li>https://github.com/MicrosoftDocs/vsonline/issues/568</li> <li>https://github.com/microsoft/vscode/issues/97396</li> </ul> <p>One comment by @jcansdale summed it up best:</p> <p>Not having the <code>workflow</code> scope can cause a world of pain. As well as not being able to touch workflow files, you can't push workflow changes that have been merged from <code>master</code>. Users can easily end up with branches that they can't push. \ud83d\ude28</p> <p>If you're using OAuth app tokens to authenticate for your <code>git</code> pushes, it seems unsafe to merge; instead, you should probably rebase.</p>"},{"location":"blog/2020/06/14/on-github-actions-security-controls/#suggestions","title":"Suggestions","text":"<p>GitHub should limit access to repository secrets by branch name; likely layered on top of the existing \"branch protections\" framework. Alone, this would be the single, most valuable security improvement; I could stick my secrets in operational branches defined by branch name pattern rules. (Caveat: GitHub needs to fix the bypass that allows an arbitrary user with <code>write</code> access to create a nonexisting branch that matches branch protection rules.)</p> <p>The control point for the logic for selecting which branches to evaluate for workflows should change. Only changes to the repository's default (Typically <code>master</code>) branch should affect branch eligibility. That way, changes to branch filtering rules must pass through whatever other controls are in place for the repository, be it <code>CODEOWNERS</code>, review requirements, or even passing linting and automated sanity checks.</p> <p>GitHub should introduce an OAuth token scope that grants the same level of access as granted by SSH usage. I don't doubt we'll see more repository controls and tie-ins migrate to in-repository representations; it's too elegant a solution to integrity, transparency, and traceability to pass up. However, if GitHub introduces a new OAuth scope each time they do this, they'll wreak havoc on tools that are only trying to ship code around.</p> <p>Finally, GitHub should consider making it feasible for one repository's defined workflows to respond to another repository's events. Or to allow different repositories' workflows to send events to each other so that the processing logic can be controlled separately from the code processed. Doing so is less than ideal from a DevOps tight-feedback-loop perspective, and wouldn't be my preferred approach. Still, the looser coupling makes managing various security considerations much less complicated.</p>"},{"location":"blog/2022/08/31/mike-reads/","title":"Mike Reads","text":"<p>So, this is an introductory post for my \"Mike Reads\" series, where I'll write about what I'm reading. Mostly, I think, because I want to analyze it and take some kind of notes. No promises I'll avoid spoilers, and this is not a judgment-free zone.</p> <p>Mostly, I'd like to start by reading through the book series I've already read. Discworld. Wheel of Time. Dragera. Tolkien. Earthsea. The Farseer Trilogy. I'm interested in recognizing clever devices, mechanisms and concepts. (Yes, tropes, but TVTropes doesn't cover it all.)</p> <p>I'll probably also read some other things I've already read, like Goldratt's The Goal and It's Not Luck, or Gene Kim's The Phoenix Project and The Unicorn Project. Maybe some nonfiction, but I dunno. I've already laid out a pretty big project here.</p> <p>There's also going to be a \"Mike Writes\" series, where I'll write about things I'm writing.</p>"},{"location":"blog/2022/08/31/mike-writes/","title":"Mike Writes","text":"<p>So, this is an introductory post for my \"Mike Writes\" series, where I'll...write. I'll write about things I'm writing like my D&amp;D settings. Or maybe lyrics to a song I wrote for one of my characters. I don't have a firm idea yet on the structure of this series, I...just like to write.</p> <p>There's also going to be a \"Mike Reads\" series, where I'll write about things I'm reading.</p>"},{"location":"blog/2022/09/01/phoenix-guards-pt-1/","title":"The Phoenix Guards Pt 1: In Which Your Author Writes an Introduction","text":"<p>The Phoenix Guards applies a fantasy bent to Dumas's The Three Musketeers, and the first in a set of books called The Khaavren Romances.</p> <p>If you'd care for a traditional book review, Jo Walton's over at Tor is fine. If you'd care to cut straight to the TVTropes page, you can do that, too, though it's all wrapped up under Dragera. While not as bad as, say, the TVTropes pages around the MCU, you won't be able to filter down to just the examples in The Phoenix Guards.</p> <p>That's a shame because the Khaavren Romances are rich. Like, they're dripping with character and detail, and I love it; if books are like food, the Khaavren Romances are like a plate of ribs; no matter how careful you are eating them, you're going to need a trip to the sink to wash lest you get everything you touch sticky. You get a similar kind of richness from Tolkien (especially the Silmarillion) and a different kind of richness in The Dresden Files. Steven Brust's Khaavren Romances closest counterpart among anything I've read is, really, Discworld, except where (GNU) Terry Pratchett writes a setting that deliberately challenges the reader's expectations, Brust writes a setting that's very nearly hard sci-fi with fantasy trappings.</p> <p>I should explain that.</p> <p>The Dragera setting, of which The Phoenix Guards and The Khaavren Romances are part, feels like it could be very real. Everything that seems mystical or supernatural is eventually explained with a consistently-applied mechanic. Whether it's an energy model that applies to souls, the nature and existence of gods and multidimensional aliens, or the nature of magic itself, once it's been explained, a reread of the entire series won't find any inconsistencies. This is Magic A is Magic A, time and time again.</p> <p>I had intended to convert a bunch of notes into a blog post, but I wound up writing an introduction instead.  So, until next time.</p>"}]}